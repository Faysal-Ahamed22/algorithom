#include<bits/stdc++.h>
using namespace std;
#define ll  long long
#define pb   push_back
#define yes   cout<<"YES"<<endl
#define no   cout<<"NO"<<endl
#define all(x) (x).begin(), (x).end()
#define    gcd(a,b)      __gcd(a,b)
#define    lcm(a,b)  (a*b)/__gcd(a,b)
#define optimize() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);

const ll mx=2012; 
char grid[mx][mx]; 
ll n,m,x,y,l,r; 
ll dx[4] = {-1, 1, 0, 0};
ll  dy[4] = {0, 0, -1, 1};
const ll inf=1e15; 
ll cost[mx][mx]; 

bool is_valid(ll i,ll j){
    if(i>=0 && i<n && j>=0 && j<m && grid[i][j]=='.')return 1; 
    return 0; 
}

void bfs(ll x,ll y){
     
    for(ll i=0; i<n; i++){
        for(ll j=0; j<m; j++)cost[i][j]=inf; 
    }

    cost[x][y]=0; 
    deque<pair<ll,ll>>dq; 
    dq.pb({x,y}); 

    while(!dq.empty())
    {
        ll i=dq.front().first,j=dq.front().second; 
        dq.pop_front(); 
        for(ll k=0; k<4; k++)
        {
            ll nx=dx[k]+i; 
            ll ny=dy[k]+j; 
            if(is_valid(nx,ny)){
                ll w; 
                if(ny==j-1)w=1; 
                else w=0; 
                if(cost[nx][ny]>cost[i][j]+w){
                    cost[nx][ny]=cost[i][j]+w; 
                    if(w==0)dq.push_front({nx,ny}); 
                    else dq.pb({nx,ny}); 
                }
            }
        }
    }

}

void solve(){

   cin>>n>>m>>x>>y>>l>>r; 
   x--;y--; 
   for(ll i=0; i<n; i++)
   {
     for(ll j=0; j<m; j++)cin>>grid[i][j]; 
   }

   bfs(x,y); 
   ll ans=0; 
   for(ll i=0; i<n; i++)
   {
     for(ll j=0; j<m; j++)
     {
        ll right=cost[i][j]+(j-y); 
        ll left=cost[i][j]; 
        if(left<=l && right<=r)ans++; 
     }
   }
   cout<<ans<<endl;

}

int main()
{
    optimize();
    ll t=1;
    //cin>>t;
    for(ll tc=1 ; tc<=t; tc++)
    {
        //cout<<"Case "<<tc<<": "; 
        solve();
    }
}
/*****************  ALHAMDULILLAH  *****************/
